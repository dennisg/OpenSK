diff --git a/boards/nordic/nrf52840_dongle/Makefile b/boards/nordic/nrf52840_dongle/Makefile
index 61dc5759..437e7f45 100644
--- a/boards/nordic/nrf52840_dongle/Makefile
+++ b/boards/nordic/nrf52840_dongle/Makefile
@@ -23,6 +23,9 @@ TOCKLOADER_JTAG_FLAGS = --jlink --board nrf52dk
 flash: target/$(TARGET)/release/$(PLATFORM).bin
 	$(TOCKLOADER) $(TOCKLOADER_GENERAL_FLAGS) flash --address $(KERNEL_ADDRESS) $(TOCKLOADER_JTAG_FLAGS) $<

+target/$(TARGET)/release/$(PLATFORM).hex: target/$(TARGET)/release/$(PLATFORM).elf
+	$(Q)objcopy --output-target=ihex $^ $@
+

 # Upload the kernel over serial/bootloader
 .PHONY: program
 program: target/$(TARGET)/release/$(PLATFORM).hex
diff --git a/boards/nordic/nrf52840_dongle/layout.ld b/boards/nordic/nrf52840_dongle/layout.ld
index 657b0d26..58c85f5b 100644
--- a/boards/nordic/nrf52840_dongle/layout.ld
+++ b/boards/nordic/nrf52840_dongle/layout.ld
@@ -1,7 +1,7 @@
 MEMORY
 {
-  rom (rx)  : ORIGIN = 0x00000000, LENGTH = 128K
-  prog (rx) : ORIGIN = 0x00030000, LENGTH = 832K
+  rom (rx)  : ORIGIN = 0x00001000, LENGTH = 128K
+  prog (rx) : ORIGIN = 0x00030000, LENGTH = 704K
   ram (rwx) : ORIGIN = 0x20000000, LENGTH = 256K
 }

diff --git a/boards/nordic/nrf52840_dongle/src/main.rs b/boards/nordic/nrf52840_dongle/src/main.rs
index 9a8dccfd..858a29aa 100644
--- a/boards/nordic/nrf52840_dongle/src/main.rs
+++ b/boards/nordic/nrf52840_dongle/src/main.rs
@@ -7,6 +7,7 @@
 #![no_main]
 #![deny(missing_docs)]
 
+use cortexm4::scb;
 use kernel::component::Component;
 #[allow(unused_imports)]
 use kernel::{debug, debug_gpio, debug_verbose, static_init};
@@ -39,6 +40,9 @@ pub mod io;
 // How should the kernel respond when a process faults.
 const FAULT_RESPONSE: kernel::procs::FaultResponse = kernel::procs::FaultResponse::Panic;
 
+const VECTOR_TABLE_OFFSET: Option<&'static str> = option_env!("VECTOR_TABLE_OFFSET");
+
+
 // Number of concurrent processes this platform supports.
 const NUM_PROCS: usize = 8;
 
@@ -63,6 +67,16 @@ pub unsafe fn reset_handler() {
     // Loads relocations and clears BSS
     nrf52840::init();
 
+    if VECTOR_TABLE_OFFSET.is_some() {
+        match VECTOR_TABLE_OFFSET.unwrap().parse::<u32>() {
+            Ok(n) => {
+                // relocate vector table, interrupt vector table is at 0x1000
+                scb::set_vector_table_offset(n);
+            },
+            Err(_e) => {},
+        }
+    }
+
     let board_kernel = static_init!(kernel::Kernel, kernel::Kernel::new(&PROCESSES));
     // GPIOs
     let gpio = components::gpio::GpioComponent::new(board_kernel).finalize(
diff --git a/boards/nordic/nrf52840_dongle/Makefile b/boards/nordic/nrf52840_dongle/Makefile
index 61dc5759..b05ae495 100644
--- a/boards/nordic/nrf52840_dongle/Makefile
+++ b/boards/nordic/nrf52840_dongle/Makefile
@@ -23,7 +23,10 @@ TOCKLOADER_JTAG_FLAGS = --jlink --board nrf52dk
 flash: target/$(TARGET)/release/$(PLATFORM).bin
 	$(TOCKLOADER) $(TOCKLOADER_GENERAL_FLAGS) flash --address $(KERNEL_ADDRESS) $(TOCKLOADER_JTAG_FLAGS) $<
 
+target/$(TARGET)/release/$(PLATFORM).hex: target/$(TARGET)/release/$(PLATFORM).elf
+	$(Q)objcopy --output-target=ihex $^ $@
+
 # Upload the kernel over serial/bootloader
 .PHONY: program
 program: target/$(TARGET)/release/$(PLATFORM).hex
-	$(error Cannot program nRF52 Dongle over USB. Use \`make flash\` and JTAG)
+	$(info Cannot program nRF52 Dongle over USB. Use \`make flash\` and JTAG)
diff --git a/boards/nordic/nrf52840_dongle/src/main.rs b/boards/nordic/nrf52840_dongle/src/main.rs
index 9a8dccfd..858a29aa 100644
--- a/boards/nordic/nrf52840_dongle/src/main.rs
+++ b/boards/nordic/nrf52840_dongle/src/main.rs
@@ -7,6 +7,7 @@
 #![no_main]
 #![deny(missing_docs)]
 
+use cortexm4::scb;
 use kernel::component::Component;
 #[allow(unused_imports)]
 use kernel::{debug, debug_gpio, debug_verbose, static_init};
@@ -39,6 +40,9 @@ pub mod io;
 // How should the kernel respond when a process faults.
 const FAULT_RESPONSE: kernel::procs::FaultResponse = kernel::procs::FaultResponse::Panic;
 
+const VECTOR_TABLE_OFFSET: Option<&'static str> = option_env!("VECTOR_TABLE_OFFSET");
+
+
 // Number of concurrent processes this platform supports.
 const NUM_PROCS: usize = 8;
 
@@ -63,6 +67,16 @@ pub unsafe fn reset_handler() {
     // Loads relocations and clears BSS
     nrf52840::init();
 
+    if VECTOR_TABLE_OFFSET.is_some() {
+        match VECTOR_TABLE_OFFSET.unwrap().parse::<u32>() {
+            Ok(n) => {
+                // relocate vector table, interrupt vector table is at 0x1000
+                scb::set_vector_table_offset(n);
+            },
+            Err(_e) => {},
+        }
+    }
+
     let board_kernel = static_init!(kernel::Kernel, kernel::Kernel::new(&PROCESSES));
     // GPIOs
     let gpio = components::gpio::GpioComponent::new(board_kernel).finalize(
@@ -144,6 +158,7 @@ pub unsafe fn reset_handler() {
         FAULT_RESPONSE,
         nrf52840::uicr::Regulator0Output::V3_0,
         false,
+        &Some(&nrf52840::usbd::USBD),
         chip,
     );
 }
diff --git a/boards/nordic/nrf52840dk/src/main.rs b/boards/nordic/nrf52840dk/src/main.rs
index 127c4f2f..f0b303bf 100644
--- a/boards/nordic/nrf52840dk/src/main.rs
+++ b/boards/nordic/nrf52840dk/src/main.rs
@@ -102,7 +102,7 @@ pub mod io;
 // Whether to use UART debugging or Segger RTT (USB) debugging.
 // - Set to false to use UART.
 // - Set to true to use Segger RTT over USB.
-const USB_DEBUGGING: bool = false;
+const USB_DEBUGGING: bool = true;
 
 // State for loading and holding applications.
 // How should the kernel respond when a process faults.
@@ -112,7 +112,7 @@ const FAULT_RESPONSE: kernel::procs::FaultResponse = kernel::procs::FaultRespons
 const NUM_PROCS: usize = 8;
 
 #[link_section = ".app_memory"]
-static mut APP_MEMORY: [u8; 0x3C000] = [0; 0x3C000];
+static mut APP_MEMORY: [u8; 0x3A000] = [0; 0x3A000];
 
 static mut PROCESSES: [Option<&'static dyn kernel::procs::ProcessType>; NUM_PROCS] =
     [None, None, None, None, None, None, None, None];
@@ -236,6 +236,7 @@ pub unsafe fn reset_handler() {
         FAULT_RESPONSE,
         nrf52840::uicr::Regulator0Output::DEFAULT,
         false,
+        &Some(&nrf52840::usbd::USBD),
         chip,
     );
 }
diff --git a/boards/nordic/nrf52dk/src/main.rs b/boards/nordic/nrf52dk/src/main.rs
index d67ac695..b0bd8bf1 100644
--- a/boards/nordic/nrf52dk/src/main.rs
+++ b/boards/nordic/nrf52dk/src/main.rs
@@ -213,6 +213,7 @@ pub unsafe fn reset_handler() {
         FAULT_RESPONSE,
         nrf52832::uicr::Regulator0Output::DEFAULT,
         false,
+        &None,
         chip,
     );
 }
diff --git a/boards/nordic/nrf52dk_base/src/lib.rs b/boards/nordic/nrf52dk_base/src/lib.rs
index fe493727..535e5cd8 100644
--- a/boards/nordic/nrf52dk_base/src/lib.rs
+++ b/boards/nordic/nrf52dk_base/src/lib.rs
@@ -101,9 +101,17 @@ pub struct Platform {
         'static,
         capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52::rtc::Rtc<'static>>,
     >,
+    usb: Option<
+        &'static capsules::usb::usb_ctap::CtapUsbSyscallDriver<
+            'static,
+            'static,
+            nrf52::usbd::Usbd<'static>,
+        >,
+    >,
     // The nRF52dk does not have the flash chip on it, so we make this optional.
     nonvolatile_storage:
         Option<&'static capsules::nonvolatile_storage_driver::NonvolatileStorage<'static>>,
+    nvmc: &'static nrf52::nvmc::SyscallDriver,
 }
 
 impl kernel::Platform for Platform {
@@ -128,6 +136,10 @@ impl kernel::Platform for Platform {
             capsules::nonvolatile_storage_driver::DRIVER_NUM => {
                 f(self.nonvolatile_storage.map_or(None, |nv| Some(nv)))
             }
+            nrf52::nvmc::DRIVER_NUM => f(Some(self.nvmc)),
+            capsules::usb::usb_ctap::DRIVER_NUM => {
+                f(self.usb.map(|ctap| ctap as &dyn kernel::Driver))
+            }
             kernel::ipc::DRIVER_NUM => f(Some(&self.ipc)),
             _ => f(None),
         }
@@ -155,6 +167,7 @@ pub unsafe fn setup_board<I: nrf52::interrupt_service::InterruptService>(
     app_fault_response: kernel::procs::FaultResponse,
     reg_vout: Regulator0Output,
     nfc_as_gpios: bool,
+    usb: &Option<&'static nrf52::usbd::Usbd<'static>>,
     chip: &'static nrf52::chip::NRF52<I>,
 ) {
     // Make non-volatile memory writable and activate the reset button
@@ -405,6 +418,52 @@ pub unsafe fn setup_board<I: nrf52::interrupt_service::InterruptService>(
     );
     nrf52::acomp::ACOMP.set_client(analog_comparator);
 
+    let nvmc = static_init!(
+        nrf52::nvmc::SyscallDriver,
+        nrf52::nvmc::SyscallDriver::new(
+            &nrf52::nvmc::NVMC,
+            board_kernel.create_grant(&memory_allocation_capability)
+        )
+    );
+
+    // Configure USB controller if supported
+    let usb_driver: Option<
+        &'static capsules::usb::usb_ctap::CtapUsbSyscallDriver<
+            'static,
+            'static,
+            nrf52::usbd::Usbd<'static>,
+        >,
+    > = usb.map(|driver| {
+        let usb_ctap = static_init!(
+            capsules::usb::usbc_ctap_hid::ClientCtapHID<
+                'static,
+                'static,
+                nrf52::usbd::Usbd<'static>,
+            >,
+            capsules::usb::usbc_ctap_hid::ClientCtapHID::new(driver)
+        );
+        driver.set_client(usb_ctap);
+
+        // Enable power events to be sent to USB controller
+        nrf52::power::POWER.set_usb_client(driver);
+        nrf52::power::POWER.enable_interrupts();
+
+        // Configure the USB userspace driver
+        let usb_driver = static_init!(
+            capsules::usb::usb_ctap::CtapUsbSyscallDriver<
+                'static,
+                'static,
+                nrf52::usbd::Usbd<'static>,
+            >,
+            capsules::usb::usb_ctap::CtapUsbSyscallDriver::new(
+                usb_ctap,
+                board_kernel.create_grant(&memory_allocation_capability)
+            )
+        );
+        usb_ctap.set_client(usb_driver);
+        usb_driver as &'static _
+    });
+
     // Start all of the clocks. Low power operation will require a better
     // approach than this.
     nrf52::clock::CLOCK.low_stop();
@@ -437,8 +496,10 @@ pub unsafe fn setup_board<I: nrf52::interrupt_service::InterruptService>(
         temp: temp,
         alarm: alarm,
         analog_comparator: analog_comparator,
+        usb: usb_driver,
         nonvolatile_storage: nonvolatile_storage,
         ipc: kernel::ipc::IPC::new(board_kernel, &memory_allocation_capability),
+        nvmc: nvmc,
     };
 
     platform.pconsole.start();
